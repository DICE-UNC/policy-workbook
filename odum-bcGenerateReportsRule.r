bcGenerateReportsRule {
# odum-bcGenerateReportsRule.r
# Command to be executed - Located in irods/server/bin/cmd/bc_generate_reports
# This invokes a Python code which generates a set of reports based on the XML file
# generated by the Fiwalk utility, Feature files generated by the Bulk Extractor tool
# and the annotated files generated by the identify_filenames tool.
# Input Parameters are:
#   annotatedFilesDir,
#   xml file generated by fiwalk tool
#   Configuration file
# Output Parameter is:
#   Output directory newBcReportsDir where the reports are generated.
# Tool: bc_generate_reports --fiwalk_xmlfile </path/to/xmlfile/> --annotated_dir </path/to/annotatedDir/ \
#                           --outdir </path/to/outdir/> --conf </path/to/configfile/>
#
# Example: irule -F rulemsiBcGenerateReports.r "*fiwalkXmlFile='/home/sunitha/aaa/x2'" \
#                   "*annotatedDir='/home/sunitha/aaa/ann2'" \
#                   "*outReportsDir='/home/sunitha/aaa/nnn4'" \
#                   "*conf='/home/sunitha/aaa/t'"
#
    *Cmd="bc_generate_reports";
    #*Arg="--fiwalk_xmlfile " ++ *fiwalkXmlFile ++ " --annotated_dir " ++ *annotatedDir ++ " --outdir " ++ *outReportsDir ++ " --conf " ++ *conf ;
    *timeStamp = double (time());
    msiSplitPath (*fiwalkXmlFile, *Coll, *File);
    # Query the metadata catalog check whether "image" exists
    Q1 = select count(DATA_NAME) where DATA_NAME = '*File' and COLL_NAME = '*Coll';
    foreach(*R1 in *Q1) {
      *Num = *R1.DATA_NAME;
      if (*Num == "0") {
        writeLine("stdout", "Please enter path to XML file");
        fail;
      }
    }

    # hintPath is the 4th argument of msiExecCmd, which is a file on the grid
    # The command will be executed on the host where this file is stored. We can use the file
    # *fiwalkXmlFile for this purpose as we know it is stored on the grid.
    *hintPath = "*fiwalkXmlFile";

    # XML File exists

    # Now Make a query to get the path to the config file and the resource name
    # DATA_PATH: Physical path name for digital object in resource
    # DATA_RESC_NAME: Logical name of storage resource
    *Query = select DATA_PATH, DATA_RESC_NAME where DATA_NAME = '*File' and COLL_NAME = '*Coll';
    foreach (*row in *Query) {
        *PathToXmlFile = *row.DATA_PATH;
        *Resource = *row.DATA_RESC_NAME;
        writeLine("stdout", "D: Path to XML file = *PathToXmlFile, Resource= *Resource");

    }

    # Query the metadata catalog for Config File
    msiSplitPath (*conf, *Coll1, *File1);
    Q1 = select count(DATA_NAME) where DATA_NAME = '*File1' and COLL_NAME = '*Coll1';
    foreach(*R1 in *Q1) {
      *Num = *R1.DATA_NAME;
      if (*Num == "0") {
        writeLine("stdout", "Please enter path to Config file");
        fail;
      }
    }

    # Config File exists

    # Now Make a query to get the path to the Config file and the resource name
    # DATA_PATH: Physical path name for digital object in resource
    # DATA_RESC_NAME: Logical name of storage resource
    *Query_c = select DATA_PATH, DATA_RESC_NAME where DATA_NAME = '*File1' and COLL_NAME = '*Coll1';
    foreach (*row in *Query_c) {
        *PathToConfigFile = *row.DATA_PATH;
        *Resource = *row.DATA_RESC_NAME;
        writeLine("stdout", "D: Path to Config file = *PathToConfigFile, Resource= *Resource");

    }

    # Make another query for IP Address of the resource
    # RESC_LOC: Resource IP Address
    # DATA_RESC_NAME: Logical name of storage resource
    *Query2 = select RESC_LOC where DATA_RESC_NAME = '*Resource';
    foreach (*row in *Query2) {
        *Addr = *row.RESC_LOC;
        writeLine("stdout", "D: Host Name = *Addr, Resource= *Resource");
    }

    # Query the metadata catalog for the input directory annotatedDir
    # First get the Collection ID (CollID_beFeat) of the Directory. Fail if the
    # directory doesn't exist
    *Q = select count(COLL_NAME) where COLL_NAME = '*annotatedDir';
    foreach(*R in *Q) {
    *CollID_annotate = *R.COLL_NAME;
    }
    if (int(*CollID_annotate) == 0) {
        writeLine("stdout", "Please enter a Directory name for BE Annotated Files Directory input");
        fail;
    }

    # Get the physical path for the directory/collection for
    # annotated files directory from DATA_PATH
    *Query3 = select DATA_PATH where COLL_ID = '*CollID_annotate';

    foreach (*row3 in *Query3) {
        *annFile = *row3.DATA_PATH;

        # The collection name is the same for all the files. So get the
        # collection name for the first one and break out of the loop.
        msiSplitPath(*annFile, *Coll, *File);

        writeLine("stdout", "D: Feature Directory:annFile: *annFile, PathToAnnDir = *Coll, File=*File");
        *PathToAnnDir = *Coll;
        break;
    }

    # store the directory of the base collection for future use
    msiSplitPath(*Coll, *baseCollDir, *annDir);

    writeLine("stdout", "D: Collection Dir = *PathToAnnDir");
    writeLine("stdout", "D: baseCollDir: *baseCollDir");

    # To have a unique name for the generated directory, we will use a prefix
    # with timestamp and user-id. The unique dir will be generated in /tmp
    # directory, which will later be copied to the datagrid.
    *prefixStr = "*timeStamp$userNameClient";
    *tempStr = "/tmp/*prefixStr" ++ "outReportsDir";

    *Arg1 = "--fiwalk_xmlfile";
    *Arg2 = execCmdArg(*PathToXmlFile);      # XmlFile:Input
    *Arg3 = "--annotated_dir";
    *Arg4 = execCmdArg(*PathToAnnDir);       # annotatedDir: Input
    *Arg5 = "--outdir";
    *Arg6 = execCmdArg(*tempStr); # Output Feature Directory
    *Arg7 = "--conf";
    *Arg8 = execCmdArg(*PathToConfigFile);

    writeLine("stdout”, “iRODS: Generating BitCurator Reports...");
    writeLine ("stdout”, “Command: *Cmd *Arg1 *Arg2 *Arg3 *Arg4 *Arg5 *Arg6 *Arg7 *Arg8");

    if (errorcode(msiExecCmd(*Cmd,"*Arg1 *Arg2 *Arg3 *Arg4 *Arg5 *Arg6 *Arg7 *Arg8”, “null”, “*hintPath”, “null",*Result)) < 0) {
        if(errormsg(*Result,*msg)==0) {
            msiGetStderrInExecCmdOut(*Result,*Out);
            writeLine("stdout", "ERROR: *Out");
        } else {
            writeLine("stdout", "Result msg is empty");
        }
    } else {
        # Command executed successfully
        msiGetStdoutInExecCmdOut(*Result,*Out);

        # Display the output from the command
        writeLine("stdout", "Command Output: \n *Out ");

        # Copy the files from /tmp to the specified output directory
        # structure recursively.
        writeLine("stdout", "Copying files from *tempStr to *outReportsDir");

        copyFiles(*Addr, *tempStr, *outReportsDir, *prefixStr, *CollID_annotate, *hintPath, *status);

        # Clean up the temporary files
        cleanup(*Addr, *tempStr, *outReportsDir, *prefixStr, *status);
    }

}

# Function: copyFiles()
# copyFiles is called for copying the files in the newly generated directory in
# /tmp to the datagrid.

copyFiles: input string * input string * input string * input string * input integer * input string * output integer -> integer
copyFiles(*Addr, *tempStr, *outReportsDir, *prefixStr, *CollID_beFeat, *hintPath, *status) {

    writeLine("stdout", "copyFiles: Moving *tempStr to *outReportsDir");

    remote(*Addr, "null") {
        # Get the list of the generated report files and copy one by one
        # Shell script bcListFiles is used to list the files in the
        # temporary directory created in /tmp. The files are to be listed in full-path and one per line
        # for the uploadFiles utility function to work,
        # bcListFiles: find $1 -type f -printf "%p\n"

        *a1 = execCmdArg(*tempStr);
        msiExecCmd("bcListFiles",*a1, "null", "*hintPath", "null", *Result);

        msiGetStdoutInExecCmdOut(*Result, *Out);

        # Call split to put the listed files in an array
        *a = split(*Out, "\n");

        ## writeLine("stdout", "D: Files in /tmp:  *Out");
        ## writeLine("stdout", "D: Files in the array are  *a ");

        *localRoot = *tempStr;

        # Call uploadFiles to copy all the files under *localRoot
        uploadFiles(*localRoot, *a, *outReportsDir)
    }
}

# Function: cleanup: Calls a script to remove the temporary files created
# in /tmp
cleanup: input string * input string * input string * input string * output integer -> integer
cleanup(*Addr, *tempStr, *outAnnDir, *prefixStr, *status) {

       writeLine("stdout", "Cleanup: Removing temporary files");
       remote(*Addr, "null") {
            *Arg1 =  execCmdArg(*prefixStr);
            msiExecCmd("tmpCleanup", *Arg1, "null", "null", "null", *Result);
       }
}

INPUT *fiwalkXmlFile="/AstroZone/home/pixel/bcfiles/bcTestFiwalkXmlfile.xml", *annotatedDir="/AstroZone/home/pixel/bcfiles/bcTestBeAnnDir", *outReportsDir="/AstroZone/home/pixel/bcfiles/outReportsDir", *conf="/AstroZone/home/pixel/bcfiles/bcTestConfigFile"
OUTPUT ruleExecOut
